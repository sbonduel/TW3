import { Callout } from 'nextra/components'

# **Introduction à Node.js**

## Qu'est-ce que Node.js ?

> Un Environnement d'exécution JavaScript côté serveur

Node.js est un environnement d'exécution permettant d'exécuter du code JavaScript côté serveur. Contrairement à son utilisation traditionnelle dans les navigateurs web, Node.js permet d'utiliser JavaScript pour des tâches côté serveur, telles que le développement d'API, la gestion de bases de données, et l'interaction avec les fichiers. Node.js utilise le moteur JavaScript V8 de Google pour exécuter du code JavaScript avec une grande performance.

### Pourquoi utiliser Node.js ? (Non-bloquant, asynchrone, performant)
Node.js se distingue par sa gestion non-bloquante et asynchrone des opérations d'entrée/sortie (I/O), telles que les lectures/écritures de fichiers, ou les appels réseau. Voici pourquoi ces caractéristiques sont cruciales :

- **Non-bloquant** : Contrairement aux environnements traditionnels, où une requête doit être terminée avant de pouvoir en traiter une autre, Node.js permet d'exécuter plusieurs opérations en parallèle. Cela améliore la réactivité des applications, en particulier dans les environnements à forte charge.

- **Asynchrone** : Le modèle asynchrone de Node.js permet de traiter les opérations lourdes en arrière-plan sans bloquer l'exécution des autres tâches. Cela permet de maximiser l'efficacité du serveur et de minimiser les temps d'attente des utilisateurs.

- **Performant** : Avec son moteur V8, Node.js exécute le code JavaScript rapidement. Sa capacité à gérer un grand nombre de connexions simultanées avec une faible empreinte mémoire le rend performant et scalable, idéal pour les applications temps réel comme les services de chat, les notifications push, ou les API web.

<Callout type="info" emoji="ℹ️">
**Historique et créateur (Ryan Dahl)**

Node.js a été créé par **Ryan Dahl** en 2009. Dahl a développé Node.js en réponse aux limitations des serveurs web traditionnels qui bloquaient souvent les requêtes lorsqu'ils effectuaient des opérations d'entrée/sortie. Il a construit Node.js sur le moteur V8 de Google pour permettre une exécution rapide du JavaScript, combinée à un modèle d'entrées/sorties asynchrone et orienté événements. Grâce à cette innovation, Node.js est rapidement devenu populaire dans l'écosystème du développement web, en particulier pour les applications réseau à grande échelle.
</Callout>

## Fonctionnement de Node.js

### Architecture orientée événements et modèle I/O non-bloquant
Node.js repose sur une **architecture orientée événements**, où le serveur attend de recevoir des événements (comme des requêtes HTTP) et réagit en conséquence. Chaque opération d'entrée/sortie (I/O) dans Node.js est asynchrone et non-bloquante, ce qui signifie que le serveur peut traiter d'autres requêtes pendant que les opérations sont en cours.

Dans un environnement traditionnel, lorsqu'une requête est effectuée, le serveur attend la fin du traitement (comme la lecture d'un fichier ou l'accès à une base de données) avant de passer à la suivante. Node.js, grâce à son **modèle non-bloquant**, évite ce problème en utilisant des **callbacks**, des **promesses**, ou la syntaxe **async/await** pour gérer les résultats d'opérations sans bloquer l'exécution du code.

### Différence entre Node.js et un serveur traditionnel (par exemple, PHP)
Les serveurs traditionnels, tels que ceux utilisant **PHP**, sont généralement **bloquants**, ce qui signifie que chaque requête doit être terminée avant que le serveur ne passe à la suivante. Cette approche est suffisante pour des charges modérées, mais devient inefficace lorsque le serveur est confronté à un grand nombre de connexions simultanées.

Node.js, en revanche, gère les connexions de manière asynchrone. Plutôt que de créer un nouveau thread pour chaque requête (comme le fait PHP), Node.js utilise un **seul thread principal** pour toutes les requêtes et délègue les opérations lourdes (telles que les lectures de fichiers ou les accès réseau) à des **workers** internes. Cela permet à Node.js de gérer efficacement des milliers de connexions simultanées tout en minimisant l'utilisation des ressources serveur.